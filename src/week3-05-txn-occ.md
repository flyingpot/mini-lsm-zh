
# 事务与乐观并发控制

在本章中，您将全面实现 `Transaction` 接口。您的实现将维护一个事务内部的私有修改空间，并在提交时批量应用这些修改，确保事务内的所有变更在提交前仅对事务本身可见。我们仅在提交时进行冲突检测（即，可串行化冲突检测），这种策略被称为乐观并发控制。

要运行测试用例，请执行以下命令：

```
cargo x copy-test --week 3 --day 5
cargo x scheck
```

## 任务1：本地工作区 + Put 和 Delete

在这个任务中，您需要修改以下文件：

```
src/txn.rs
```

您可以通过将相应的键/值插入到 `local_storage` 中来实现 `put` 和 `delete` 操作。`local_storage` 是一个没有键时间戳的跳表内存表。注意，对于删除操作，应插入一个空值而非直接从跳表中移除该值。

## 任务2：Get 和 Scan

在这个任务中，您需要修改以下文件：

```
src/txn.rs
```

对于 `get` 操作，首先在本地存储中查找。如果找到值，根据是否为删除标记返回该值或 `None`。对于 `scan` 操作，您需要为跳表实现一个 `TxnLocalIterator`，类似于第1.1章节中为没有键时间戳的内存表实现的迭代器。您需要在 `TxnIterator` 中存储一个 `TwoMergeIterator>`。此外，由于 `TwoMergeIterator` 会保留子迭代器中的删除标记，您需要调整 `TxnIterator` 实现以正确处理删除操作。

## 任务3：Commit

在这个任务中，您需要修改以下文件：

```
src/txn.rs
```

我们假设事务仅在单线程中使用。一旦事务进入提交阶段，应将 `self.committed` 设置为 true，防止用户在事务上执行其他操作。如果事务已提交，`put`、`delete`、`scan` 和 `get` 操作应返回错误。

提交操作应简单地从本地存储中收集所有键值对，并向存储引擎提交一个写批处理。

## 任务4：原子 WAL

在这个任务中，您需要修改以下文件：

```
src/wal.rs
src/mem_table.rs
```

注意，`commit` 操作涉及生成一个写批处理，而目前，写批处理不保证原子性。您需要更改 WAL 实现，为写批处理生成一个头部和一个尾部。

新的 WAL 编码格式如下：

```
|   HEADER   |                          BODY                                      |  FOOTER  |
|     u32    |   u16   | var | u64 |    u16    |  var  |           ...            |    u32   |
| batch_size | key_len | key | ts  | value_len | value | more key-value pairs ... | checksum |
```

`batch_size` 表示 `BODY` 部分的大小。`checksum` 是 `BODY` 部分的校验和。

没有专门的测试用例来验证您的实现。只要您通过所有现有的测试用例并实现上述 WAL 格式，一切应该都没问题。

您应实现 `Wal::put_batch` 和 `MemTable::put_batch`。原来的 `put` 函数应将单个键值对视为一个批处理。也就是说，此时，您的 `put` 函数应调用 `put_batch`。

一个批处理应在同一个内存表和同一个 WAL 中处理，即使它超过了内存表的大小限制。

## 测试您的理解

* 通过到目前为止我们实现的所有功能，系统是否满足快照隔离？如果不是，我们还需要做什么来支持快照隔离？（注意：快照隔离不同于我们将在下一章讨论的可串行化快照隔离）
* 如果用户想要批量导入数据（例如，1TB？）如果他们使用事务 API 来完成这个任务，您会给他们什么建议？有没有机会针对这种情况进行优化？
* 什么是乐观并发控制？如果我们改为在 Mini-LSM 中实现悲观并发控制，系统会是什么样子？
* 如果系统崩溃并在磁盘上留下一个损坏的 WAL，您如何处理这种情况？

## 额外任务

* **溢出到磁盘。** 如果事务的私有工作区变得太大，您可以将部分数据刷新到磁盘。

{{#include copyright.md}}
