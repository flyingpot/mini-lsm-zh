
# 块构建器和块迭代器



这是 Mini-LSM 教程的旧版本，我们将不再维护它。我们现在有一个更好的版本，这一章节现在是 [Mini-LSM 第一周第三天：块](./week1-03-block.md) 的一部分。




在这一部分，你需要修改以下文件：

* `src/block/builder.rs`
* `src/block/iterator.rs`
* `src/block.rs`

你可以使用 `cargo x copy-test day1` 将我们提供的测试用例复制到初始代码目录中。完成这部分后，使用 `cargo x scheck` 检查样式并运行所有测试用例。如果你想编写自己的测试用例，请在 `block.rs` 中编写一个新的模块 `#[cfg(test)] mod user_tests { /* 你的测试用例 */ }`。记得移除你修改的模块顶部的 `#![allow(...)]`，以便 cargo clippy 可以实际检查样式。

## 任务 1 - 块构建器

块是 LSM 中最小的读取单元。一般来说，块的大小为 4KB，类似于数据库页面。在每个块中，我们将存储一系列排序的键值对。

你需要修改 `src/block/builder.rs` 中的 `BlockBuilder`，以构建编码数据和偏移数组。块包含两部分：数据和偏移量。

```
---------------------------------------------------------------------
| 数据  | 偏移量 | 元数据 |
| ----- | ------- | ----- |
| 条目 | 条目   | 条目 | 条目 | 偏移 | 偏移 | 偏移 | 偏移 | 元素数量 |
---------------------------------------------------------------------
```

当用户向块添加键值对（即条目）时，我们需要将其序列化为以下格式：

```
-----------------------------------------------------------------------
|                          条目 #1                            | ... |
-----------------------------------------------------------------------
| 键长度 (2B) | 键 (键长度) | 值长度 (2B) | 值 (可变长度) | ... |
-----------------------------------------------------------------------
```

键长度和值长度均为 2 字节，这意味着它们的最大长度为 65535。（内部存储为 `u16`）

我们假设键永远不会为空，而值可以为空。空值意味着在系统的其他部分看来，相应的键已被删除。对于 `BlockBuilder` 和 `BlockIterator`，我们只需将其视为空值。

在每个块的末尾，我们将存储每个条目的偏移量和条目的总数。例如，如果第一个条目位于块的第 0 个位置，第二个条目位于块的第 12 个位置。

```
-------------------------------
|偏移|偏移|元素数量|
-------------------------------
|   0  |  12  |       2       |
-------------------------------
```

块的尾部将如上所示。每个数字都存储为 `u16`。

块有一个大小限制，即 `target_size`。除非第一个键值对超过目标块大小，否则应确保编码的块大小始终小于或等于 `target_size`。（在提供的代码中，这里的 `target_size` 实际上是 `block_size`）

当调用 `build` 时，`BlockBuilder` 将生成数据部分和未编码的条目偏移量。这些信息将存储在 `Block` 结构体中。由于键值条目以原始格式存储，偏移量存储在单独的向量中，这减少了不必要的内存分配和处理开销——你需要做的就是简单地将原始块数据复制到 `data` 向量中，并每 2 字节解码条目偏移量，而不是创建类似 `Vec<(Vec, Vec)>` 的结构来存储一个块中的所有键值对。这种紧凑的内存布局非常高效。

对于编码和解码部分，你需要修改 `src/block.rs` 中的 `Block`。具体来说，你需要实现 `Block::encode` 和 `Block::decode`，这将编码为/解码自上述图示的数据布局。

## 任务 2 - 块迭代器

给定一个 `Block` 对象，我们需要提取键值对。为此，我们创建一个块上的迭代器并找到我们需要的信息。

`BlockIterator` 可以通过一个 `Arc` 创建。如果调用 `create_and_seek_to_first`，它将定位在块中的第一个键。如果调用 `create_and_seek_to_key`，迭代器将定位在第一个大于等于提供的键的位置。例如，如果块中有 `1, 3, 5`。

```rust
let mut iter = BlockIterator::create_and_seek_to_key(block, b"2");
assert_eq!(iter.key(), b"3");
```

上面的 `seek 2` 将使迭代器定位在下一个可用的键 `2`，在这种情况下是 `3`。

迭代器应从块中复制 `key` 和 `value` 并存储在迭代器内部，以便用户可以通过 `fn key(&self) -> &[u8]` 直接访问本地存储的键和值，而无需额外的复制。

当调用 `next` 时，迭代器将移动到下一个位置。如果我们到达块的末尾，我们可以将 `key` 设置为空并从 `is_valid` 返回 `false`，以便调用者可以在可能的情况下切换到另一个块。

完成这部分后，你应该能够通过 `block/tests.rs` 中的所有测试。

## 额外任务

以下是你可以做的额外任务列表，以使块编码更加健壮和高效。

*注意：在实现这部分后，某些测试用例可能无法通过。你可能需要编写自己的测试用例。*

* 实现块校验和。在解码块时验证校验和。
* 压缩/解压块。在 `build` 时压缩，在解码时解压。

{{#include copyright.md}}
