
# SST 构建器和 SST 迭代器



这是 Mini-LSM 教程的旧版本，我们将不再维护它。我们现在有一个更好的版本，这一章节现在是 [Mini-LSM 第一周第四天：排序字符串表（SST）](./week1-04-sst.md) 的一部分。




在这一部分，你需要修改以下文件：

* `src/table/builder.rs`
* `src/table/iterator.rs`
* `src/table.rs`

你可以使用 `cargo x copy-test day2` 命令将我们提供的测试用例复制到初始代码目录中。完成这一部分后，使用 `cargo x scheck` 检查样式并运行所有测试用例。如果你想编写自己的测试用例，请在 `table.rs` 中编写一个新的模块 `#[cfg(test)] mod user_tests { /* 你的测试用例 */ }`。记得移除你修改的模块顶部的 `#![allow(...)]`，以便 cargo clippy 可以实际检查样式。

## 任务 1 - SST 构建器

SST（Sorted String Table）由存储在磁盘上的数据块和索引块组成。通常，数据块是惰性加载的——它们不会被加载到内存中，直到用户请求它们。索引块也可以按需加载，但在本教程中，我们假设所有 SST 索引块（元块）都可以适应内存。一般来说，一个 SST 文件的大小为 256MB。

SST 构建器类似于块构建器——用户将在构建器上调用 `add`。你应该在 SST 构建器内部维护一个 `BlockBuilder`，并在必要时拆分块。此外，你需要维护块元数据 `BlockMeta`，其中包括每个块的第一个键和每个块的偏移量。`build` 函数将编码 SST，使用 `FileObject::create` 将所有内容写入磁盘，并返回一个 `SsTable` 对象。注意，在第二部分中，你不需要实际将数据写入磁盘。只需将所有内容作为向量存储在内存中，直到我们实现块缓存（第四天，任务 5）。

SST 的编码如下：

```
-------------------------------------------------------------------------------------------
|         数据块部分          |          元数据部分          |          额外部分          |
-------------------------------------------------------------------------------------------
| 数据块 | ... | 数据块 | 元数据块 | ... | 元数据块 | 元数据块偏移量 (u32) |
-------------------------------------------------------------------------------------------
```

你还需要实现 `SsTableBuilder` 的 `estimated_size` 函数，以便调用者可以知道何时可以开始写入新的 SST。该函数不需要非常精确。假设数据块包含的数据远多于元数据块，我们可以简单地返回数据块的大小作为 `estimated_size`。

你还可以将块对齐到 4KB 边界，以便将来可能进行直接 I/O。这是一个可选的优化。

完成 **任务 1** 的推荐顺序如下：

- 在 `src/table/builder.rs` 中实现 `SsTableBuilder`
  - 在实现 `SsTableBuilder` 之前，你可能想查看 `src/table.rs` 中的 `FileObject` 和 `BlockMeta`。
  - 对于 `FileObject`，你至少应该在第四天之前实现 `read`、`size` 和 `create`（不需要磁盘 I/O）。
  - 对于 `BlockMeta`，在编码/解码 `BlockMeta` 到/从缓冲区时，你可能想添加一些额外的字段。
- 在 `src/table.rs` 中实现 `SsTable`
  - 与上面相同，你不需要担心块缓存直到第四天。

完成 **任务 1** 后，你应该能够通过除两个迭代器测试之外的所有当前测试。

## 任务 2 - SST 迭代器

与 `BlockIterator` 类似，你需要实现一个遍历 SST 的迭代器。注意，你应该按需加载数据。例如，如果你的迭代器在块 1 上，它不应该在到达下一个块之前在内存中保留任何其他块内容。

`SsTableIterator` 应该实现 `StorageIterator` 特性，以便将来可以与其他迭代器组合。

需要注意的一点是 `seek_to_key` 函数。基本上，你需要在块元数据上进行二分搜索，以找到可能包含该键的块。可能该键不存在于 LSM 树中，因此块迭代器将在 seek 之后立即失效。例如，

```
----------------------------------
| 块 1 | 块 2 | 块元数据 |
----------------------------------
| a, b, c | e, f, g | 1: a, 2: e |
----------------------------------
```

如果我们在这个 SST 中执行 `seek(b)`，这很简单——使用二分搜索，我们可以知道块 1 包含键 `a <= keys < e`。因此，我们加载块 1 并将块迭代器定位到相应的位置。

但如果我们执行 `seek(d)`，我们将定位到块 1，但在块 1 中查找 `d` 将到达块的末尾。因此，我们应该在 seek 之后检查迭代器是否无效，并在必要时切换到下一个块。

## 额外任务

以下是你可以做的额外任务列表，以使块编码更健壮和高效。

*注意：实现这一部分后，某些测试用例可能无法通过。你可能需要编写自己的测试用例。*

* 实现索引校验和。在解码时验证校验和。
* 探索不同的 SST 编码和布局。例如，在 [Lethe](https://disc-projects.bu.edu/lethe/) 论文中，作者向 SST 添加了辅助键支持。

{{#include copyright.md}}
