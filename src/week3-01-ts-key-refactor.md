
# 时间戳键编码与重构

在本章中，你将：

* 重构你的实现以使用 key+ts 表示法。
* 使你的代码使用新的键表示法编译通过。

要运行测试用例，请执行以下命令：

```
cargo x copy-test --week 3 --day 1
cargo x scheck
```

**注意：本章节没有完整的单元测试。你只需要确保代码能编译通过。**

## 任务 0：使用 MVCC 键编码

你需要将键编码模块替换为 MVCC 键编码。我们从原始键模块中移除了一些接口，并为键实现了新的比较器。如果你按照前几章的指示操作，并且没有在键上使用 `into_inner`，你应该在所有重构后通过第 3 天的所有测试用例。否则，你需要仔细检查那些只比较键而不查看时间戳的地方。

具体来说，键类型定义已从：

```rust,no_run
pub struct Key>(T);
```

改为：

```rust,no_run
pub struct Key>(T /* 用户键 */, u64 /* 时间戳 */);
```

我们在键中关联了一个时间戳。我们仅在系统内部使用这种键表示法。在用户接口方面，我们不要求用户提供时间戳，因此某些结构仍然使用 `&[u8]` 而不是 `KeySlice` 在引擎中。稍后我们将介绍需要更改函数签名的地方。目前，你只需要运行以下命令：

```
cp mini-lsm-mvcc/src/key.rs mini-lsm-starter/src/
```

还有其他存储时间戳的方法。例如，我们仍然可以使用 `pub struct Key>(T);` 表示法，但假设键的最后 8 个字节是时间戳。你也可以将此作为额外任务实现。

```plaintext
替代键表示法： | 用户键 (可变长度) | 时间戳 (8 字节) | 在单个切片中
我们的键表示法： | 用户键切片 | 时间戳 (u64) |
```

在 key+ts 编码中，具有最小用户键和最大时间戳的键将首先排序。例如：

```
("a", 233) < ("a", 0) < ("b", 233) < ("b", 0)
```

## 任务 1：在块中编码时间戳

你首先会注意到的是，替换键模块后你的代码可能无法编译。在本章中，你只需要确保它能编译通过。在这个任务中，你需要修改以下文件：

```
src/block.rs
src/block/builder.rs
src/block/iterator.rs
```

你会注意到 `raw_ref()` 和 `len()` 已从键 API 中移除。取而代之的是，我们有 `key_ref` 来检索用户键的切片，以及 `key_len` 来检索用户键的长度。你需要重构你的块构建器和解码实现以使用新的 API。此外，你需要更改块编码以编码时间戳。在 `BlockBuilder::add` 中，你应该这样做。新的块条目记录将类似于：

```
键重叠长度 (u16) | 剩余键长度 (u16) | 键 (剩余键长度) | 时间戳 (u64)
```

你可以使用 `raw_len` 来估计键所需的空间，并将时间戳存储在用户键之后。

更改块编码后，你需要相应地更改 `block.rs` 和 `iterator.rs` 中的解码。

## 任务 2：在 SST 中编码时间戳

然后，你可以继续修改表格式，

```
src/table.rs
src/table/builder.rs
src/table/iterator.rs
```

具体来说，你需要更改块元数据编码以包含键的时间戳。所有其他代码保持不变。由于我们在所有函数的签名中使用 `KeySlice`（即 seek, add），新的键比较器应自动按用户键和时间戳排序键。

在你的表构建器中，你可以直接使用 `key_ref()` 来构建布隆过滤器。这自然为你的 SST 创建了一个前缀布隆过滤器。

## 任务 3：LSM 迭代器

由于我们使用关联的泛型类型来使大多数迭代器适用于不同的键类型（即 `&[u8]` 和 `KeySlice<'_>`），如果我们正确实现，我们不需要修改合并迭代器和连接迭代器。`LsmIterator` 是我们从内部键表示中去除时间戳并将键的最新版本返回给用户的地方。在这个任务中，你需要修改：

```
src/lsm_iterator.rs
```

目前，我们不修改 `LsmIterator` 的逻辑以仅保留键的最新版本。我们只是通过在传递给内部迭代器的用户键上附加时间戳使其编译通过，并在返回给用户时去除键的时间戳。目前，你的 LSM 迭代器的行为应该是向用户返回同一键的多个版本。

## 任务 4：内存表

目前，我们保持内存表的逻辑。我们向用户返回一个键切片，并以 `TS_DEFAULT` 刷新 SST。我们将在下一章中将内存表改为 MVCC。在这个任务中，你需要修改：

```
src/mem_table.rs
```

## 任务 5：引擎读取路径

在这个任务中，你需要修改，

```
src/lsm_storage.rs
```

现在我们在键中有一个时间戳，并且在创建迭代器时，我们需要使用带时间戳的键而不是仅用户键进行查找。你可以使用 `TS_RANGE_BEGIN` 创建一个键切片，这是最大的时间戳。

当你检查一个用户键是否在表中时，你可以仅比较用户键而不比较时间戳。

此时，你应该构建你的实现并通过所有第 1 周的测试用例。系统中存储的所有键将使用 `TS_DEFAULT`（即时间戳 0）。我们将在接下来的两章中使引擎完全多版本并通过所有测试用例。

{{#include copyright.md}}
