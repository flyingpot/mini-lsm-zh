
# 水印与垃圾回收

在本章中，您将实现必要的结构来跟踪用户使用的最低读取时间戳，并在进行压缩时从 SST 中收集未使用的版本。

要运行测试用例，请执行以下命令：

```
cargo x copy-test --week 3 --day 4
cargo x scheck
```

## 任务1：实现水印

在本任务中，您需要修改：

```
src/mvcc/watermark.rs
```

水印结构用于跟踪系统中最低的读取时间戳。当创建新事务时，应调用 `add_reader` 将其读取时间戳添加到跟踪中。当事务中止或提交时，应将其从水印中移除。当调用 `watermark()` 时，水印结构会返回系统中最低的 `read_ts`。如果没有正在进行的事务，则简单返回 `None`。

您可以使用 `BTreeMap` 来实现水印。它维护一个计数器，用于记录每个 `read_ts` 有多少快照正在使用。B 树映射中不应有读者数为 0 的条目。

## 任务2：在事务中维护水印

在本任务中，您需要修改：

```
src/mvcc/txn.rs
src/mvcc.rs
```

在事务启动时，应将 `read_ts` 添加到水印中，并在事务调用 `drop` 时将其移除。

## 任务3：在压缩中进行垃圾回收

在本任务中，您需要修改：

```
src/compact.rs
```

现在我们有了系统的水印，我们可以在压缩过程中清理未使用的版本。

* 如果某个键的版本高于水印，则保留它。
* 对于所有低于或等于水印的键版本，应保留其最新版本。

例如，如果我们有水印=3 和以下数据：

```
a@4=del <- 高于水印
a@3=3   <- 低于或等于水印的最新版本
a@2=2   <- 可以移除，没有人会读取它
a@1=1   <- 可以移除，没有人会读取它
b@1=1   <- 低于或等于水印的最新版本
c@4=4   <- 高于水印
d@3=del <- 如果在压缩到底层时可以移除
d@2=2   <- 可以移除
```

如果我们对这些键进行压缩，我们将得到：

```
a@4=del
a@3=3
b@1=1
c@4=4
d@3=del (如果在压缩到底层时可以移除)
```

假设这些是引擎中的所有键。如果在 ts=3 时进行扫描，我们将在压缩前/后得到 `a=3,b=1,c=4`。如果在 ts=4 时进行扫描，我们将在压缩前/后得到 `b=1,c=4`。压缩不会也不应该影响读取时间戳 >= 水印的事务。

## 测试您的理解

* 在我们的实现中，我们通过事务的生命周期自行管理水印（所谓的非托管模式）。如果用户打算自行管理键时间戳和水印（例如，当他们有自己的时间戳生成器时），您需要在 write_batch/get/scan API 中验证他们的请求吗？在这种情况下，我们是否有任何架构假设可能难以维护？
* 为什么我们需要在事务迭代器中存储 `Transaction` 的 `Arc`？
* 完全从 SST 文件中移除键的条件是什么？
* 目前，我们仅在压缩到底层时移除键。还有其他时间可以移除键吗？（提示：您知道所有级别中每个 SST 的开始/结束键。）
* 考虑用户创建了一个长时间运行的事务，我们无法进行垃圾回收的情况。用户不断更新单个键。最终，单个 SST 文件中可能会有数千个键版本。这将如何影响性能，您将如何处理？

## 额外任务

* **O(1) 水印。** 您可以使用哈希映射或循环队列来实现摊销 O(1) 时间复杂度的水印结构。

{{#include copyright.md}}
