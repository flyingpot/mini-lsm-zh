
# 批量写入与校验和



在前一章中，您已经构建了一个完整的基于LSM的存储引擎。在本周末，我们将实现一些简单但重要的存储引擎优化。欢迎来到Mini-LSM的第二周小吃时间！

在本章中，您将：

* 实现批量写入接口。
* 为块、SST元数据、清单文件和WAL添加校验和。

**注意：本章没有单元测试。只要您通过所有之前的测试并确保校验和在文件格式中正确编码，就可以了。**

## 任务1：批量写入接口

在这个任务中，我们将为本周的第三部分准备，添加一个批量写入API。您需要修改：

```
src/lsm_storage.rs
```

用户通过`write_batch`提供一批记录，这些记录将被写入数据库。记录是`WriteBatchRecord>`，因此可以是`Bytes`、`&[u8]`或`Vec`。有两种类型的记录：删除和插入。您可以像处理`put`和`delete`函数一样处理它们。

之后，您可以重构原始的`put`和`delete`函数，调用`write_batch`。

实现此功能后，您应该通过之前章节的所有测试用例。

## 任务2：块校验和

在这个任务中，您需要在编码SST时在每个块的末尾添加一个块校验和。您需要修改：

```
src/table/builder.rs
src/table.rs
```

SST的格式将变为：

```plaintext
---------------------------------------------------------------------------------------------------------------------------
|                   Block Section                     |                            Meta Section                           |
---------------------------------------------------------------------------------------------------------------------------
| data block | checksum | ... | data block | checksum | metadata | meta block offset | bloom filter | bloom filter offset |
|   varlen   |    u32   |     |   varlen   |    u32   |  varlen  |         u32       |    varlen    |        u32          |
---------------------------------------------------------------------------------------------------------------------------
```

我们使用crc32作为校验和算法。您可以使用`crc32fast::hash`在构建块后生成块的校验和。

通常，当用户在存储选项中指定目标块大小时，该大小应包括块内容和校验和。例如，如果目标块大小是4096，校验和占用4字节，实际块内容目标大小应为4092。然而，为了避免破坏之前的测试用例并简化操作，在本教程中，我们将**仍然**使用目标块大小作为目标内容大小，并在块末尾简单地附加校验和。

在读取块时，您应该在`read_block`中正确验证校验和，为块内容生成切片。实现此功能后，您应该通过之前章节的所有测试用例。

## 任务3：SST元数据校验和

在这个任务中，您需要为布隆过滤器和块元数据添加块校验和：

```
src/table/builder.rs
src/table.rs
src/bloom.rs
```

```plaintext
----------------------------------------------------------------------------------------------------------
|                                                Meta Section                                            |
----------------------------------------------------------------------------------------------------------
| no. of block | metadata | checksum | meta block offset | bloom filter | checksum | bloom filter offset |
|     u32      |  varlen  |    u32   |        u32        |    varlen    |    u32   |        u32          |
----------------------------------------------------------------------------------------------------------
```

您需要在`Bloom::encode`和`Bloom::decode`中在布隆过滤器的末尾添加校验和。请注意，我们的许多API接受一个现有的缓冲区，实现将写入该缓冲区，例如`Bloom::encode`。因此，您应该在写入编码内容之前记录布隆过滤器开始的偏移量，并且只校验布隆过滤器本身而不是整个缓冲区。

之后，您可以在块元数据的末尾添加校验和。您可能会发现，在元数据部分的开头添加元数据长度会很有帮助，这样在解码块元数据时更容易知道在哪里停止。

## 任务4：WAL校验和

在这个任务中，您需要修改：

```
src/wal.rs
```

我们将在预写日志中对每条记录进行校验和。为此，您有两种选择：

* 生成键值记录的缓冲区，并使用`crc32fast::hash`一次性计算校验和。
* 一次写入一个字段（例如，键长度、键切片），并使用`crc32fast::Hasher`在每个字段上增量计算校验和。

这取决于您的选择，您需要*选择自己的冒险*。两种方法应产生完全相同的结果，只要您正确处理小端/大端。新的WAL编码应如下：

```
| key_len | key | value_len | value | checksum |
```

## 任务5：清单文件校验和

最后，让我们在清单文件中添加一个校验和。清单文件类似于WAL，除了之前我们没有存储每条记录的长度。为了使实现更容易，我们现在在记录的开头添加一个记录长度的头，并在记录的末尾添加一个校验和。

新的清单文件格式如下：

```
| len | JSON record | checksum | len | JSON record | checksum | len | JSON record | checksum |
```

实现所有内容后，您应该通过之前章节的所有测试用例。本章没有提供新的测试用例。

## 测试您的理解

* 考虑一个LSM存储引擎只提供`write_batch`作为写入接口（而不是单个put + delete）。是否可以如下实现：有一个单一的写入线程，通过mpsc通道接收器获取更改，所有线程将写入批处理发送到写入线程。写入线程是写入数据库的单一入口点。这种实现的优缺点是什么？（如果您这样做，恭喜您获得BadgerDB！）
* 将所有块校验和一起放在SST文件的末尾而不是与块一起存储是否可以？为什么？

我们没有提供这些问题的参考答案，欢迎在Discord社区中讨论。

## 额外任务

* **恢复损坏时**。如果出现校验和错误，以安全模式打开数据库，以便无法执行写入操作，并且可以检索未损坏的数据。

{{#include copyright.md}}
