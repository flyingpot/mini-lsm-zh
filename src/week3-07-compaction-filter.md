
# 零食时间：压缩过滤器

恭喜！你做到了！在上一章中，你使你的 LSM 引擎具备了多版本功能，用户可以使用事务 API 与你的存储引擎进行交互。在本周末，我们将实现一些简单但重要的存储引擎功能。欢迎来到 Mini-LSM 的第三周零食时间！

在本章中，我们将把我们的压缩垃圾收集逻辑泛化为压缩过滤器。

目前，我们的压缩过程只是保留水位线以上的键和水位线以下键的最新版本。我们可以在压缩过程中添加一些魔法，帮助用户在后台自动收集一些未使用的数据。

考虑一个用户使用 Mini-LSM 存储数据库表的情况。表中的每一行都以前缀表名开头。例如：

```
table1_key1 -> 行
table1_key2 -> 行
table1_key3 -> 行
table2_key1 -> 行
table2_key2 -> 行
```

现在用户执行 `DROP TABLE table1`。引擎需要清理所有以 `table1` 开头的数据。

有很多方法可以实现这个目标。Mini-LSM 的用户可以扫描所有以 `table1` 开头的键，并请求引擎删除它们。然而，扫描一个非常大的数据库可能会很慢，并且会生成与现有键相同数量的删除墓碑。因此，扫描和删除不会释放被删除表占用的空间——相反，它会增加引擎中的数据，并且只有在墓碑到达引擎的底层时才能回收空间。

或者，他们可以创建列族（我们将在《余生》章节中讨论这个）。他们将每个表存储在一个列族中，这是一个独立的 LSM 状态，当用户删除表时，直接删除与该列族对应的 SST 文件。

在本教程中，我们将实现第三种方法：压缩过滤器。压缩过滤器可以在运行时动态添加到引擎中。在压缩过程中，如果找到与压缩过滤器匹配的键，我们可以在后台静默删除它。因此，用户可以向引擎附加一个 `prefix=table1` 的压缩过滤器，所有这些键将在压缩过程中被删除。

## 任务 1：压缩过滤器

在这个任务中，你需要修改：

```
src/compact.rs
```

你可以在 `LsmStorageInner::compaction_filters` 中遍历所有压缩过滤器。如果水位线以下键的第一个版本与压缩过滤器匹配，只需将其删除而不是保留在 SST 文件中。

要运行测试用例，

```
cargo x copy-test --week 3 --day 7
cargo x scheck
```

你可以假设用户不会获取前缀过滤器范围内的键。并且，他们不会扫描前缀范围内的键。因此，当用户请求前缀过滤器范围内的键时，返回错误值是可以的（即未定义行为）。

{{#include copyright.md}}
